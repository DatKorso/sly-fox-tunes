"""YouTube downloader service using yt-dlp."""

from __future__ import annotations

import asyncio
from pathlib import Path
from typing import Any

import yt_dlp
from loguru import logger


class DownloadError(Exception):
    """Custom exception for download errors."""

    pass


async def get_video_info(url: str) -> dict[str, Any]:
    """
    Extract video information from YouTube URL.

    Args:
        url: YouTube video URL

    Returns:
        Dictionary with video info containing:
            - title: Video title
            - duration: Duration in seconds
            - thumbnail: Thumbnail URL
            - uploader: Channel name
            - view_count: Number of views

    Raises:
        DownloadError: If video info cannot be extracted
    """
    ydl_opts = {
        "quiet": True,
        "no_warnings": True,
        "extract_flat": False,
    }

    try:
        logger.info(f"Extracting video info from: {url}")

        # Run yt-dlp in executor to avoid blocking
        loop = asyncio.get_event_loop()
        info = await loop.run_in_executor(None, lambda: _extract_info_sync(url, ydl_opts))

        result = {
            "title": info.get("title", "Unknown"),
            "duration": info.get("duration", 0),
            "thumbnail": info.get("thumbnail", ""),
            "uploader": info.get("uploader", "Unknown"),
            "view_count": info.get("view_count", 0),
        }

        logger.info(f"Successfully extracted info for: {result['title']}")
        return result

    except Exception as e:
        logger.error(f"Failed to extract video info: {e}")
        raise DownloadError(f"Could not get video information: {e}") from e


def _extract_info_sync(url: str, ydl_opts: dict[str, Any]) -> dict[str, Any]:
    """Synchronous helper to extract info with yt-dlp."""
    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
        return ydl.extract_info(url, download=False)


async def download_video(url: str, output_path: Path) -> Path:
    """
    Download video from YouTube in MP4 format.

    Downloads video with 720p quality (or best available if 720p not available).

    Args:
        url: YouTube video URL
        output_path: Path where to save the downloaded video

    Returns:
        Path to the downloaded video file

    Raises:
        DownloadError: If download fails
    """
    # Ensure output directory exists
    output_path.parent.mkdir(parents=True, exist_ok=True)

    ydl_opts = {
        "format": "bestvideo[height<=720][ext=mp4]+bestaudio[ext=m4a]/best[height<=720][ext=mp4]/best",
        "outtmpl": str(output_path),
        "quiet": True,
        "no_warnings": True,
        "merge_output_format": "mp4",
    }

    try:
        logger.info(f"Starting video download from: {url}")
        logger.info(f"Output path: {output_path}")

        # Run yt-dlp in executor to avoid blocking
        loop = asyncio.get_event_loop()
        await loop.run_in_executor(None, lambda: _download_sync(url, ydl_opts))

        # yt-dlp may add .mp4 extension if not present
        if not output_path.exists():
            # Try with .mp4 extension
            output_path_with_ext = output_path.with_suffix(".mp4")
            if output_path_with_ext.exists():
                output_path = output_path_with_ext
            else:
                raise DownloadError("Downloaded file not found")

        logger.info(f"Successfully downloaded video to: {output_path}")
        return output_path

    except Exception as e:
        logger.error(f"Failed to download video: {e}")
        raise DownloadError(f"Could not download video: {e}") from e


async def download_audio(url: str, output_path: Path) -> Path:
    """
    Download audio from YouTube in MP3 format.

    Downloads audio with 192kbps quality.

    Args:
        url: YouTube video URL
        output_path: Path where to save the downloaded audio

    Returns:
        Path to the downloaded audio file

    Raises:
        DownloadError: If download fails
    """
    # Ensure output directory exists
    output_path.parent.mkdir(parents=True, exist_ok=True)

    ydl_opts = {
        "format": "bestaudio/best",
        "outtmpl": str(output_path),
        "quiet": True,
        "no_warnings": True,
        "postprocessors": [
            {
                "key": "FFmpegExtractAudio",
                "preferredcodec": "mp3",
                "preferredquality": "192",
            }
        ],
    }

    try:
        logger.info(f"Starting audio download from: {url}")
        logger.info(f"Output path: {output_path}")

        # Run yt-dlp in executor to avoid blocking
        loop = asyncio.get_event_loop()
        await loop.run_in_executor(None, lambda: _download_sync(url, ydl_opts))

        # yt-dlp will add .mp3 extension after conversion
        output_path_mp3 = output_path.with_suffix(".mp3")
        if not output_path_mp3.exists() and output_path.exists():
            # If original file exists but not mp3, use original
            output_path_mp3 = output_path
        elif not output_path_mp3.exists():
            raise DownloadError("Downloaded file not found")

        logger.info(f"Successfully downloaded audio to: {output_path_mp3}")
        return output_path_mp3

    except Exception as e:
        logger.error(f"Failed to download audio: {e}")
        raise DownloadError(f"Could not download audio: {e}") from e


def _download_sync(url: str, ydl_opts: dict[str, Any]) -> None:
    """Synchronous helper to download with yt-dlp."""
    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
        ydl.download([url])


class DownloaderService:
    """Service class wrapper for downloader functions."""

    async def get_video_info(self, url: str) -> dict[str, Any]:
        """Get video information."""
        return await get_video_info(url)

    async def download_video(self, url: str, output_path: Path) -> Path:
        """Download video."""
        return await download_video(url, output_path)

    async def download_audio(self, url: str, output_path: Path) -> Path:
        """Download audio."""
        return await download_audio(url, output_path)
